[[argument_passing]]
= Argument passing and evaluation
// TODO: Much of this can probably be combined with the section on pointers and references...?
* Arguments can be any expression that produces a value:
    literal, variable, operation(s), result of another function call

== Strict evaluation
** Argument expressions are evaluated before the function is called;
      the resulting value is passed to the fn.
** The vast majority of languages, and all C-style languages, use strict eval
      for functions

== Pass (call) by value vs. by reference
** Pass by value: argument's value is copied to parameter
***  Good, because argument won't be changed if parameter is altered inside
        function
***  Bad, because value must be copied in memory (e.g. big obj.)
** Pass by reference: argument's memory location copied to parameter
***  Good, because you only need to copy a memory location (not entire obj.)
***  Bad, because argument is shared
**** change to param will also change arg - ignores scope
          semantics, automatically makes fn. an impure fn.
***  Some languages (Clu) refer to this as "call-by-sharing;"
        but the term is not widely used
** C/C++ reference semantics
***  Start with these, because they are the basis for other lang's, and the
        explicit differences will make understanding other lang's easier
***  C/C++: Pointers
****  When passing by pointer, the pointer itself is passed by value;
          that is, the memory address is copied
****  Pass a value type by pointer:
[source,{cpp}]
----
void f(int* param); // function prototype
// in caller:
int arg = 5;
f(&arg);            // note address-of operator
f(&5);              // won't compile - must be addr of lvalue
----
****  Arrays are just "syntactic sugar" for pointer:
[source,{cpp}]
----
// Function declaration (prototype):
int f(int[] arr);    // Formal parameter is array of int's
int f(int* arr);     // Identical behavior!
// in caller:
int result;
int[] arr = {5, 6, 7. 8, 9};
result = f(arr);     // Note: no address-of operator
result = f(&arr[0]); // Identical behavior!
----
****  The C/C++ term for this is a "simulated reference"
            Semantically identical to pointer, but does not use pointer syntax
***  C++: References
****  When passing by reference, the parameter becomes an alias of the
              argument value
****  Pass a value type by reference:
[source,{cpp}]
----
void f(int& x); // function prototype
// in caller:
int arg = 5;
f(arg);         // no address-of operator!
f(5);           // won't compile - reference must be mutable
----

***  References vs. pointers: semantically different
[source,{cpp}]
----
// Pass by pointer function definition
void passPtr(int* p)
{
  int x = 5;
  p = &x;
}
// Pass by reference function definition
void passRef(int& r)
{
  int x = 5;
  r = x;
}
// In caller:
int a = 3;
passPtr(&a);  // a has value 3; its mem loc was passed by value
passRef(a);   // a has value 5!
// What about using a pointer?
a = 3;        // reset back to 3
int* b = &a;
passPtr(b);   // a has value 3; b was passed by value
passRef(*b);  // a has value 5!
----
***  const params: making shared arguments immutable
****  Pointers:
[source,{cpp}]
----
void f1(const int* param);       // *param is const; no assignment
void f2(int* const param);       // param is const; *param is not!
void f3(const int* const param); // param and *param are const
// in caller:
int arg = 5;
f1(&arg); // arg can't change (param can be re-referenced)
f2(&arg); // arg can change! (param can't be re-referenced)
f3(&arg); // arg can't change value (param can't be re-referenced)
----
****  References:
[source,{cpp}]
----
int f(const int& param); // param is completely immutable
// in caller:
int arg = 5;
f(arg); // arg can't change
f(5);   // this will compile! arg is reference to immutable rvalue
----
** Other C-style languages:
***  Value types are *always* passed by value
***  Reference types are passed by reference, but a "reference" is
        semantically identical to a pointer - i.e. they are what C/C++ calls
        "pass by simulated reference"
***  In PHP, references are aliases to symbol table entries:
          http://php.net/manual/en/language.references.php
        HOWEVER, they behave semantically like pass-by-pointer
== Variadic Functions
// TODO

// TODO: Merge this with the "Argument Evaluation Strategy" section in "Using Functions"?
== Non-strict evaluation strategies
* Argument expressions are not evaluated until/unless they are used in the function body
* Example problem: mimic if/then/else statement with function
[source,{cpp}]
----
// Function definition
int if_then_else(bool if_exp, int then_exp, int else_exp) {
   if (if_exp) {
       return then_exp;
   }
   else {
       return else_exp;
   }
}
// Function call - parentheses are for clarity
a = 1;
b = 0;
if_then_else((b > 0), (5 / b), (5 / a));
----

Strict evaluation produces a divide-by-zero error at runtime!
This shouldn't happen, because `(5 / b)` should not be evaluated.
(Other example: sort-circuiting for `||` and `&&` operators)

Non-strict evaluation can "fix" this behavior.

* Variations:
** Call-by-macro-expansion: the argument expression code is literally
     substituted for the parameter when it is used. Example:
[source,{cpp}]
----
 // function call as before:
 if_then_else((b > 0), (5 / b), (5 / a));
 // The body of the function literally becomes:
 int if_then_else(bool if_exp, int then_exp, int else_exp) {
    if ((b > 0)) {
        return (5 / b);
    }
    else {
        return (5 / a);
    }
}
----

*** But, call-by-macro-expansion needs a way for `f()` to know values for
      `a` and `b`; only possible if they have global scope

** Call-by-name: similar to call-by-macro-expansion, but language
    automatically keeps reference to caller's scope

** Call-by-need: similar to call-by-name, but the language holds a record
    of the results of a function call with specific parameters; so the
    function is only evaluated once (per set of parameter values), and is
    returned from the record on subsequent calls
*** Memoization
*** Won't work for impure functions (e.g. random number generator)
