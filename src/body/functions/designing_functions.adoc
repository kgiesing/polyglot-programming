= Designing Functions

== The Function's Domain

[quote, , Clean Code]
_____
*Small!*

The first rule of functions is that they should be small.
The second rule of functions is that *they should be smaller than that.*

[...] This implies that the blocks within if statements, else statements, while statements, and so on should be one line long.
Probably that line should be a function call.
Not only does this keep the enclosing function small,
but it also adds documentary value
because the function called within the block can have a nicely descriptive name.

This also implies that functions should not be large enough to hold nested structures.
Therefore, the indent level of a function should not be greater than one or two.
This, of course, makes the functions easier to read and understand.

*DO ONE THING*

The following advice has appeared in one form or another for 30 years or more.

FUNCTIONS SHOULD DO ONE THING.
THEY SHOULD DO IT WELL.
THEY SHOULD DO IT ONLY.

[...] If a function does only those steps that are one level below the stated name of the function,
then the function is doing one thing.

[...] Another way to know that a function is doing more than “one thing”
is if you can extract another function from it
with a name that is not merely a restatement of its implementation [G34].

*One Level of Abstraction per Function*

In order to make sure our functions are doing "one thing,"
we need to make sure that the statements within our function are all at the same level of abstraction.

*Reading Code from Top to Bottom: The Stepdown Rule*

We want the code to read like a top-down narrative.
[Kernighan and Plaugher, The Elements of Programming Style, 2d. ed., McGraw-Hill, 1978, p. 37.]
We want every function to be followed by those at the next level of abstraction so that we can read the program,
descending one level of abstraction at a time as we read down the list of functions.
I call this The Step-down Rule.

To say this differently, we want to be able to read the program as though it were a set of TO paragraphs,
each of which is describing the current level of abstraction and referencing subsequent TO paragraphs at the next level down.

*Switch Statements*

It’s hard to make a small switch statement.
[And, of course, I include if/else chains in this.]
Even a switch statement with only two cases is larger than I’d like a single block or function to be.
It’s also hard to make a switch statement that does one thing.
By their nature, switch statements always do N things.
Unfortunately we can’t always avoid switch statements,
but we can make sure that each switch statement is buried in a low-level class and is never repeated.
We do this, of course, with polymorphism.

There are several problems with this function [with a switch-statement involving employee types].
First, it’s large, and when new employee types are added, it will grow.
Second, it very clearly does more than one thing.
Third, it violates the http://www.objectmentor.com/resources/articles/srp.pdf[Single Responsibility Principle] (SRP)
because there is more than one reason for it to change.
Fourth, it violates the http://www.objectmentor.com/resources/articles/ocp.pdf[Open Closed Principle] (OCP)
because it must change whenever new types are added.
But possibly the worst problem with this function is that there are an unlimited number of other functions that will have the same structure.

The solution to this problem is to bury the switch statement in the basement of an ABSTRACT FACTORY, and never let anyone see it.
[...] My general rule for switch statements is that they can be tolerated if they appear only once,
are used to create polymorphic objects,
and are hidden behind an inheritance relationship so that the rest of the system can’t see them [G23].

*Use Descriptive Names*

[...] It is hard to overestimate the value of good names.
Remember Ward’s principle: "You know you are working on clean code when each routine turns out to be pretty much what you expected."
Half the battle to achieving that principle is choosing good names for small functions that do one thing.
The smaller and more focused a function is, the easier it is to choose a descriptive name.

[...] Don’t be afraid to make a name long.
A long descriptive name is better than a short enigmatic name.
A long descriptive name is better than a long descriptive comment.

[...] Don’t be afraid to spend time choosing a name.

[...] Be consistent in your names.
Use the same phrases, nouns, and verbs in the function names you choose for your modules.

*Function Arguments*

The ideal number of arguments for a function is zero (niladic).
[NOTE: I completely disagree, as it makes the function impure. -Karl]
Next comes one (monadic), followed closely by two (dyadic).
Three arguments (triadic) should be avoided where possible.
More than three (polyadic) requires very special justification—and then shouldn’t be used anyway.

[...] Arguments are even harder from a testing point of view.
Imagine the difficulty of writing all the test cases to ensure that all the various combinations of arguments work properly.


[...] Output arguments are harder to understand than input arguments.
When we read a function, we are used to the idea of information going in to the function through arguments and out through the return value.
We don’t usually expect information to be going out through the arguments.
So output arguments often cause us to do a double-take.
[NOTE: This can be better expressed as "prefer pure functions." - Karl]

[...] Flag arguments are ugly. Passing a boolean into a function is a truly terrible practice.
It immediately complicates the signature of the method, loudly proclaiming that this function does more than one thing.

[...] When a function seems to need more than two or three arguments, it is likely that some of those arguments ought to be wrapped into a class of their own.
[NOTE: Or a `struct` in C. -Karl]

[...] Sometimes we want to pass a variable number of arguments into a function.
[...] If the variable arguments are all treated identically, [...] then they are equivalent to a single argument[.]

[...] Choosing good names for a function can go a long way toward explaining the intent of the function and the order and intent of the arguments.
In the case of a monad, the function and argument should form a very nice verb/noun pair.
For example, write(name) is very evocative.
Whatever this “name” thing is, it is being “written.”
An even better name might be writeField(name), which tells us that the “name” thing is a “field.”

This last is an example of the *keyword* form of a function name.
Using this form we encode the names of the arguments into the function name.

*Have No Side Effects*

Side effects are lies.
Your function promises to do one thing, but it also does other hidden things.
[NOTE: Again, "prefer pure functions." - Karl]

[...] This side effect creates a temporal coupling.
That is, checkPassword can only be called at certain times (in other words, when it is safe to initialize the session).
If it is called out of order, session data may be inadvertently lost.
Temporal couplings are confusing, especially when hidden as a side effect.
[NOTE: Included because of the term "temporal coupling." -Karl]

*COMMAND QUERY SEPARATION*

Functions should either do something or answer something, but not both.
Either your function should change the state of an object, or it should return some information about that object.
Doing both often leads to confusion.

*PREFER EXCEPTIONS TO RETURNING ERROR CODES*

Returning error codes from command functions is a subtle violation of command query separation.
It promotes commands being used as expressions in the predicates of `if` statements.

[...] `Try`/`catch` blocks are ugly in their own right.
They confuse the structure of the code and mix error processing with normal processing.
So it is better to extract the bodies of the `try` and `catch` blocks out into functions of their own.

[...] Functions should do one thing.
Error handing is one thing.
Thus, a function that handles errors should do nothing else.
This implies [...] that if the keyword `try` exists in a function,
it should be the very first word in the function and that there should be nothing after the `catch`/`finally` blocks.

[...] Returning error codes usually implies that there is some class or enum in which all the error codes are defined.
[...] Classes like this are a *dependency magnet;* many other classes must import and use them.
Thus, when the Error enum changes, all those other classes need to be recompiled and redeployed.
[...] When you use exceptions rather than error codes, then new exceptions are derivatives of the exception class.
They can be added without forcing any recompilation or redeployment.
[This is an example of the Open Closed Principle (OCP) [Robert C. Martin, Agile Software Development: Principles, Patterns, and Practices, Prentice Hall, 2002].]

*DON’T REPEAT YOURSELF*

[The DRY principle. [The Pragmatic Programmer, Andrew Hunt, Dave Thomas, Addison-Wesley, 2000].]

Duplication may be the root of all evil in software.
Many principles and practices have been created for the purpose of controlling or eliminating it.

*STRUCTURED PROGRAMMING*
Some programmers follow Edsger Dijkstra’s rules of structured programming.
[Structured Programming, O.-J. Dahl, E. W. Dijkstra, C. A. R. Hoare, Academic Press, London, 1972]
Dijkstra said that every function, and every block within a function, should have one entry and one exit.
Following these rules means that there should only be one `return` statement in a function,
no `break` or `continue` statements in a loop,
and never, ever, any `goto` statements.

While we are sympathetic to the goals and disciplines of structured programming, those rules serve little benefit when functions are very small.
It is only in larger functions that such rules provide significant benefit.

So if you keep your functions small, then the occasional multiple `return`, `break`, or `continue` statement does no harm
and can sometimes even be more expressive than the single-entry, single-exit rule.
On the other hand, `goto` only makes sense in large functions, so it should be avoided.
_____


== Naming Functions
// TODO Much of this should be moved to a "designing variables" section

[quote, Tim Ottinger, Clean Code]
_____
*USE INTENTION-REVEALING NAMES*

[...] The name of a variable, function, or class, should answer all the big questions.
It should tell you why it exists, what it does, and how it is used.
If a name requires a comment, then the name does not reveal its intent.

*AVOID DISINFORMATION*

Programmers must avoid leaving false clues that obscure the meaning of code.
We should avoid words whose entrenched meanings vary from our intended meaning.
For example, `hp`, `aix`, and `sco` would be poor variable names because they are the names of Unix platforms or variants.
Even if you are coding a hypotenuse and hp looks like a good abbreviation, it could be disinformative.

*MAKE MEANINGFUL DISTINCTIONS*

Programmers create problems for themselves when they write code solely to satisfy a compiler or interpreter.
For example, because you can’t use the same name to refer to two different things in the same scope, you might be tempted to change one name in an arbitrary way.
Sometimes this is done by misspelling one, leading to the surprising situation where correcting spelling errors leads to an inability to compile.

It is not sufficient to add number series or noise words, even though the compiler is satisfied.
If names must be different, then they should also mean something different.

[...] In the absence of specific conventions, the variable moneyAmount is indistinguishable from money, customerInfo is indistinguishable from customer, accountData is indistinguishable from account, and theMessage is indistinguishable from message.
Distinguish names in such a way that the reader knows what the differences offer.

*USE PRONOUNCEABLE NAMES*

Humans are good at words.
A significant part of our brains is dedicated to the concept of words.
And words are, by definition, pronounceable.
It would be a shame not to take advantage of that huge portion of our brains that has evolved to deal with spoken language.
So make your names pronounceable.

If you can’t pronounce it, you can’t discuss it without sounding like an idiot.
"Well, over here on the bee cee arr three cee enn tee we have a pee ess zee kyew int, see?"
This matters because programming is a social activity.

*USE SEARCHABLE NAMES*

Single-letter names and numeric constants have a particular problem in that they are not easy to locate across a body of text.

[...] My personal preference is that single-letter names can ONLY be used as local variables inside short methods.
*The length of a name should correspond to the size of its scope [N5].*
If a variable or constant might be seen or used in multiple places in a body of code, it is imperative to give it a search-friendly name.

*AVOID ENCODINGS*

We have enough encodings to deal with without adding more to our burden.
Encoding type or scope information into names simply adds an extra burden of deciphering.
It hardly seems reasonable to require each new employee to learn yet another encoding “language” in addition to learning the (usually considerable) body of code that they’ll be working in.
It is an unnecessary mental burden when trying to solve a problem.
Encoded names are seldom pronounceable and are easy to mis-type.

*Hungarian Notation*

In days of old, when we worked in name-length-challenged languages, we violated this rule out of necessity, and with regret.

[...] Nowadays HN and other forms of type encoding are simply impediments.
They make it harder to change the name or type of a variable, function, or class.
They make it harder to read the code.
And they create the possibility that the encoding system will mislead the reader.

*Member Prefixes*

You also don’t need to prefix member variables with `m_` anymore.
Your classes and functions should be small enough that you don’t need them.
And you should be using an editing environment that highlights or colorizes members to make them distinct.

[...] Besides, people quickly learn to ignore the prefix (or suffix) to see the meaningful part of the name.
The more we read the code, the less we see the prefixes.
Eventually the prefixes become unseen clutter and a marker of older code.

*Interfaces and Implementations*

These are sometimes a special case for encodings.
For example, say you are building an ABSTRACT FACTORY for the creation of shapes.
This factory will be an interface and will be implemented by a concrete class.
What should you name them?
`IShapeFactory` and `ShapeFactory`?
I prefer to leave interfaces unadorned.
The preceding `I`, so common in today’s legacy wads, is a distraction at best and too much information at worst.
I don’t want my users knowing that I’m handing them an interface.
I just want them to know that it’s a `ShapeFactory`.
So if I must encode either the interface or the implementation, I choose the implementation.
Calling it `ShapeFactoryImp`, or even the hideous `CShapeFactory`, is preferable to encoding the interface.

*AVOID MENTAL MAPPING*

Readers shouldn’t have to mentally translate your names into other names they already know.
This problem generally arises from a choice to use neither problem domain terms nor solution domain terms.

This is a problem with single-letter variable names.
Certainly a loop counter may be named `i` or `j` or `k` (though never `l`!) if its scope is very small and no other names can conflict with it.
This is because those single-letter names for loop counters are traditional.
However, in most other contexts a single-letter name is a poor choice; it’s just a place holder that the reader must mentally map to the actual concept.
There can be no worse reason for using the name `c` than because `a` and `b` were already taken.

*METHOD NAMES*

Methods should have verb or verb phrase names like postPayment, deletePage, or save.
Accessors, mutators, and predicates should be named for their value and prefixed with `get`, `set`, and `is` according to the javabean standard.

*Don’t Be Cute*

If names are too clever, they will be memorable only to people who share the author’s sense of humor,
and only as long as these people remember the joke.

*Pick One Word per Concept*

Pick one word for one abstract concept and stick with it.
For instance, it’s confusing to have fetch, retrieve, and get as equivalent methods of different classes.
How do you remember which method name goes with which class?

*DON’T PUN*

Avoid using the same word for two purposes.
Using the same term for two different ideas is essentially a pun.

[...] Our goal, as authors, is to make our code as easy as possible to understand.
 We want our code to be a quick skim, not an intense study.
We want to use the popular paperback model whereby the author is responsible for making himself clear and not the academic model where it is the scholar’s job to dig the meaning out of the paper.

*Use Solution Domain Names*

Remember that the people who read your code will be programmers.
So go ahead and use computer science (CS) terms, algorithm names, pattern names, math terms, and so forth.

*Use Problem Domain Names*

When there is no “programmer-eese” for what you’re doing, use the name from the problem domain.
At least the programmer who maintains your code can ask a domain expert what it means.

*Add Meaningful Context*

There are a few names which are meaningful in and of themselves—most are not.
Instead, you need to place names in context for your reader by enclosing them in well-named classes, functions, or namespaces.
When all else fails, then prefixing the name may be necessary as a last resort.


*Don’t Add Gratuitous Context*

In an imaginary application called “Gas Station Deluxe,” it is a bad idea to prefix every class with GSD.
Frankly, you are working against your tools.
You type G and press the completion key and are rewarded with a mile-long list of every class in the system.
Is that wise?
Why make it hard for the IDE to help you?

Likewise, say you invented a MailingAddress class in GSD’s accounting module, and you named it GSDAccountAddress.
Later, you need a mailing address for your customer contact application.
Do you use GSDAccountAddress?
Does it sound like the right name?
Ten of 17 characters are redundant or irrelevant.

Shorter names are generally better than longer ones, so long as they are clear.
Add no more context to a name than is necessary.
_____
