= Basic Concepts and Terminology

A function is a named block of statements, that potentially accepts values as inputs, and potentially returns a value as output.

The concept should be familiar to anyone who has studied mathematics.
Mathematical functions also take values (usually variables) as input, and produce an output value.
But there are a number of differences between mathematical functions, and functions in programming languages:

* Mathematical functions do not change the variables used as input.
* Mathematical functions must return a unique output for each different set of inputs.
    That is, asciimath:[f(1)] cannot produce the same value as asciimath:[f(3)] (provided those numbers are in its domain).
* Mathematical functions must produce an output value.

None of those constraints exist with functions in programming languages.
Functions can take any number of inputs, including zero.
They can provide any value as output, including no value at all.

This has led programmers to classify functions into two broad categories.
Those categories are called _pure_ and _impure._

== Pure vs. Impure Functions
To be classified as a pure function, a function must:

1. be _deterministic._
    This means the output value must be solely determined by the input values.
    It cannot be determined by anything else, such as global variables or constants.

2. have no _side effects._
    A side effect is a change in the system state, outside the scope of the function itself.
    For example, it cannot change the state of input or output devices, or set global variables.
    Furthermore, it cannot change the input passed to the function;
    after the function has finished executing, the values used as input must remain the same.

An example of a pure function would be a function that performs a mathematical operation.
Let's say you're using a function that computes the value of one number raised to the power of a second.
It is given a base, `b`, and an exponent, `e`.
For this example, we'll say that `b` is 10 and `e` is 2.

The function would not use anything other than `b` and `e` to compute the output value (in this case, 100).
And, when it was finished executing, `b` would still be 10, and `e` would still be 2.

An _impure_ function is any function that is not a pure function.
Impure functions commonly change the state of the system in some way, or modify the input value.
They may also use a value that is not part of the input to produce the output value.

Here are some examples of impure functions:

* A random number generator.
    To generate a random number, it would need to use some value that wasn't given as input,
    such as a current timestamp.
    (Otherwise it wouldn't be random.)

* A function that reads from a file.
    Unless you're actually using the contents of the file as input,
    the function would return a different value depending upon the file's contents.
    (And if you _were_ using the contents as input, then what's the point?)

* A function that prints a message to the console.
    The console is part of the system state, and writing to it modifies that state.

As a general rule, pure functions are more desirable than impure functions.
They are usually easier to comprehend, easier to re-use, and easier to write.
Since they don't modify system state, there's little chance of them interfering with other functions.
They are also easier to test and debug, since there are no hidden interactions to account for.

// TODO: this is "call-by-need" - just talk about it when talking about argument evaluation?
Being deterministic, some compilers and interpreters can optimize pure function calls.
They keep a record of the output from a function call with specific arguments,
and if that function is called again with the same arguments, they just look up the returned value.

But, as you can see from the examples, a program that consists _only_ of pure functions would be useless.
The point of a program is to give an output value in some way, and that requires modifying the system state.

Choosing when to make a function impure is a design choice programmers constantly have to make.
Whatever the case, it is important to document any side effects a function might have.
Aside from the actual documentation, there are certain conventions that are used when writing impure functions.
I'll explain these conventions as they arise.

== Methods
A method is _a function that is associated with an object._
A method is not considered an entity unto itself, but is considered a _member_ of that object.

The purpose of a method is to modify the state of the object in some way,
or to return a value that is dependent upon the object's state.
In this sense, methods could be considered impure functions.
However, in all other respects, methods are usually designed to be pure functions.
They do not modify _global_ state, and they usually do not modify their input values.

Even though the term is pretty well established, there are a couple of times when other terms are used.

* In C++ literature, methods are called _member functions._
    (But even so, plenty of C++ programmers use the term "method.")

* Some programmers use the term _message_ instead.
    This reflects the idea that using a method is "sending a message" to the object.

I'll use those terms when appropriate, but like most other programmers, I'll usually use the term "method."

== Procedures and subroutines
The terms "procedure" and "subroutine" are often used instead of the term "function."
This has led to a great deal of confusion about which term to use.

And, unfortunately, that confusion remains to this day.
Programmers in different languages tend to use these terms in their own way,
and argue with other programmers who use them in a different way.
Things fall apart, the centre cannot hold, and we all slouch towards Bethlehem.

But each term is _usually_ used to mean a specific kind of function.

=== Procedures
To most programmers, a procedure is _a function that does not return a value._
All procedures are impure functions (there would be no reason to write one otherwise).

In C-syntax languages, there is no _syntactic_ difference between a function and a procedure.
Both are defined the same way, and the syntax for calling them is identical.
If a programmer in a C-syntax language even makes a distinction at all,
that distinction is purely semantic.

This is not true in other languages such as Ada and Pascal.
Unlike C-syntax languages, these languages have a different syntax for procedures and functions.
Functions and procedures are defined differently, and the compiler treats them differently.

Certain SQL languages, such as MySQL or SQL Server, also make a syntactic distinction between procedures and functions.
These are usually called "stored procedures" and "user-defined functions."
The difference between the two is specific to each "flavor" of SQL.
Generally speaking, a stored procedure can be any prepared block of SQL statements, and may return any number of values (including zero).
A function must return a single value, cannot alter the database, and has other limitations.

On the other hand, some programmers use the term "procedure" for any function.
This is usually to distinguish between the procedures used in programming, and the functions used in mathematics.
For an example, see
https://mitpress.mit.edu/books/structure-and-interpretation-computer-programs[Structure and Interpretation of Computer Programs]
by Ableson, Sussman, and Sussman.
(But only if you really want to learn the Scheme programming language.)

Because of this confusion, I will avoid using the term "procedure" altogether.

=== Subroutines
The term "subroutine" has historically been used as a synonym for what we now call a function.
From what I can tell, theoretical computer scientists usually used "function," and practical programmers usually used "subroutine."
If the author distinguished them at all, he or she used the term "function" for pure functions,
and "subroutine" to include both pure and impure functions.

Today, the term seems to have fallen out of widespread use among practical programmers.
The main exceptions are assembly language programmers, and the Fortran language.

In assembly language, a subroutine is _a named location where program execution can jump._
It is essentially the equivalent of a `goto` statement.
Returning from the subroutine involves jumping back to the location where the subroutine was called.

In this context, a subroutine is about as impure as a function can get.
It may use and modify data that is stored in machine registers, which are "global" in scope.
The "return value" is also stored in one of the general-purpose registers, before jumping back to the calling location.

In Fortran, "functions" are pure functions, and "subroutines" are impure functions.
Like procedures in Ada or Pascal, Fortran subroutines are treated differently in the language syntax.
Subroutines in Fortran cannot return a value, as functions do.
Instead, they "return" multiple values, by defining inputs that will be changed by the subroutine.
Inputs that can be changed are defined differently than inputs that cannot be changed.

But these langauages are not covered in this book, so I will also be avoiding the term "subroutine."

== Parts of a function
* identifier: name
* formal parameters: variables that represent the function's input values
** parameters vs. arguments
** variadic: variable # of args ("varargs")
* return type: value representing the function's output value passed back to caller
** omitted in implicitly-typed languages: JavaScript, PHP
** "void functions"
// TODO cover this beforehand in arrays and associative arrays
** destructuring (ES6, PHP `list`/`extract` - different >=7.1)
* body: statements that are executed when the function is called
** body may include any kind of statements: variable definitions, operations,
      or other function calls
** functions can be _defined_ inside other functions _only if_ functions are first-class citizens
*** Javascript, PHP
*** More in section on functional programming
