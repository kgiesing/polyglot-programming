= Quotes
// Note: These are specific quotes to reference in the rest of the section.
// References in the "technically correct" sense should go into src/back/references.adoc.
:toc:

== Beyond Legacy Code (Bernstein)

=== Function Design

[quote, David Scott Bernstein, Beyond Legacy Code]
_____
Smaller is better for four essential reasons:

* It’s easier to understand.
* It’s easier to estimate.
* It’s easier to implement.
* It’s easier to test.

Smaller tasks are also far less risky because they give us more opportunity for feedback.
_____
(Note: Bernstein was talking about smaller stories, but it applies to pretty much everything.)

== Code Complete, Second Edition (McConnell)

=== Function Design

[quote, Steve McConnell, "Code Complete, Second Edition"]
_____
*Design at the Routine Level*

The idea of cohesion was introduced in a paper by Wayne Stevens, Glenford Myers, and Larry Constantine (1974).
Other more modern concepts, including abstraction and encapsulation, tend to yield more insight at the class level
(and have, in fact, largely superceded cohesion at the class level),
but cohesion is still alive and well as the workhorse design heuristic at the individual-routine level.

For routines, cohesion refers to how closely the operations in a routine are related.
Some programmers prefer the term "strength": how strongly related are the operations in a routine?
[...] The goal is to have each routine do one thing well and not do anything else.

The payoff is higher reliability.
One study of 450 routines found that 50 percent of the highly cohesive routines were fault free, whereas only 18 percent of routines with low cohesion were fault free (Card, Church, and Agresti 1986).
Another study of a different 450 routines (which is just an unusual coincidence) found that routines with the highest coupling-to-cohesion ratios had 7 times as many errors as those with the lowest coupling-to-cohesion ratios and were 20 times as costly to fix (Selby and Basili 1991).

Discussions about cohesion typically refer to several levels of cohesion.
Understanding the concepts is more important than remembering specific terms.
Use the concepts as aids in thinking about how to make routines as cohesive as possible.

*Functional cohesion* is the strongest and best kind of cohesion, occurring when a routine performs one and only one operation.
Examples of highly cohesive routines include sin(), GetCustomerName(), EraseFile(), CalculateLoanPayment(), and AgeFromBirthdate().
Of course, this evaluation of their cohesion assumes that the routines do what their names say they do —
if they do anything else, they are less cohesive and poorly named.

Several other kinds of cohesion are normally considered to be less than ideal:

* *Sequential cohesion* exists when a routine contains operations that must be performed in a specific order,
that share data from step to step,
and that don't make up a complete function when done together.

* *Communicational cohesion* occurs when operations in a routine make use of the same data and aren't related in any other way.
If a routine prints a summary report and then reinitializes the summary data passed into it, the routine has communicational cohesion:
the two operations are related only by the fact that they use the same data.
+
To give this routine better cohesion, the summary data should be reinitialized close to where it's created, which shouldn't be in the report-printing routine.
Split the operations into individual routines.
The first prints the report.
The second reinitializes the data, close to the code that creates or modifies the data.
Call both routines from the higher-level routine that originally called the communicationally cohesive routine.

* *Temporal cohesion* occurs when operations are combined into a routine because they are all done at the same time.
Typical examples would be Startup(), CompleteNewEmployee(), and Shutdown().
Some programmers consider temporal cohesion to be unacceptable because it's sometimes associated with bad programming practices such as having a hodgepodge of code in a Startup() routine.
+
To avoid this problem, think of temporal routines as organizers of other events.
The Startup() routine, for example, might read a configuration file, initialize a scratch file, set up a memory manager, and show an initial screen.
To make it most effective, have the temporally cohesive routine call other routines to perform specific activities rather than performing the operations directly itself.
That way, it will be clear that the point of the routine is to orchestrate activities rather than to do them directly.

The remaining kinds of cohesion are generally unacceptable.
They result in code that's poorly organized, hard to debug, and hard to modify.
If a routine has bad cohesion, it's better to put effort into a rewrite to have better cohesion than investing in a pinpoint diagnosis of the problem.
Knowing what to avoid can be useful, however, so here are the unacceptable kinds of cohesion:

* *Procedural cohesion* occurs when operations in a routine are done in a specified order.
An example is a routine that gets an employee name, then an address, and then a phone number.
The order of these operations is important only because it matches the order in which the user is asked for the data on the input screen.
Another routine gets the rest of the employee data.
The routine has procedural cohesion because it puts a set of operations in a specified order and the operations don't need to be combined for any other reason.
+
To achieve better cohesion, put the separate operations into their own routines.
Make sure that the calling routine has a single, complete job: GetEmployee() rather than GetFirstPartOfEmployeeData().
You'll probably need to modify the routines that get the rest of the data too.
It's common to modify two or more original routines before you achieve functional cohesion in any of them.

* *Logical cohesion* occurs when several operations are stuffed into the same routine
and one of the operations is selected by a control flag that's passed in.
It's called logical cohesion because the control flow or "logic" of the routine is the only thing that ties the operations together —
they're all in a big if statement or case statement together.
It isn't because the operations are logically related in any other sense.
Considering that the defining attribute of logical cohesion is that the operations are unrelated, a better name might "illogical cohesion."
+
It's usually all right, however, to create a logically cohesive routine
if its code consists solely of a series of if or case statements and calls to other routines.
In such a case, if the routine's only function is to dispatch commands and it doesn't do any of the processing itself,
that's usually a good design.
The technical term for this kind of routine is "event handler."
An event handler is often used in interactive environments such as the Apple Macintosh, Microsoft Windows, and other GUI environments.
[NOTE: Or dispatching options from a command-line menu, or factory methods...]

* *Coincidental cohesion* occurs when the operations in a routine have no discernible relationship to each other.
Other good names are "no cohesion" or "chaotic cohesion."
The low-quality C++ routine at the beginning of this chapter had coincidental cohesion.
It's hard to convert coincidental cohesion to any better kind of cohesion—you usually need to do a deeper redesign and reimplementation.

None of these terms are magical or sacred. Learn the ideas rather than the terminology. It's nearly always possible to write routines with functional cohesion, so focus your attention on functional cohesion for maximum benefit.

*How Long Can a Routine Be?*

The theoretical best maximum length is often described as one screen or one or two pages of program listing, approximately 50 to 150 lines.
In this spirit, IBM once limited routines to 50 lines, and TRW limited them to two pages (McCabe 1976).
Modern programs tend to have volumes of extremely short routines mixed in with a few longer routines.

[...] A mountain of research on routine length has accumulated over the years,
some of which is applicable to modern programs, and some of which isn't:

* A study by Basili and Perricone found that routine size was inversely correlated with errors:
    as the size of routines increased (up to 200 lines of code), the number of errors per line of code decreased (Basili and Perricone 1984).

* Another study found that routine size was not correlated with errors,
    even though structural complexity and amount of data were correlated with errors (Shen et al. 1985).

* A 1986 study found that small routines (32 lines of code or fewer) were not correlated with lower cost or fault rate
    (Card, Church, and Agresti 1986; Card and Glass 1990).
    The evidence suggested that larger routines (65 lines of code or more) were cheaper to develop per line of code.

* An empirical study of 450 routines found that small routines
    (those with fewer than 143 source statements, including comments)
    had 23 percent more errors per line of code than larger routines
    but were 2.4 times less expensive to fix than larger routines
    (Selby and Basili 1991).

* Another study found that code needed to be changed least when routines averaged 100 to 150 lines of code
    (Lind and Vairavan 1989).

* A study at IBM found that the most error-prone routines were those that were larger than 500 lines of code.
    Beyond 500 lines, the error rate tended to be proportional to the size of the routine (Jones 1986a).

Where does all this leave the question of routine length in object-oriented programs?
A large percentage of routines in object-oriented programs will be accessor routines, which will be very short.
From time to time, a complex algorithm will lead to a longer routine,
and in those circumstances, the routine should be allowed to grow organically up to 100–200 lines.
(A line is a noncomment, nonblank line of source code.)
Decades of evidence say that routines of such length are no more error prone than shorter routines.
Let issues such as the routine's cohesion, depth of nesting, number of variables,
 number of decision points, number of comments needed to explain the routine,
 and other complexity-related considerations dictate the length of the routine rather than imposing a length restriction per se.

That said, if you want to write routines longer than about 200 lines, be careful.
None of the studies that reported decreased cost, decreased error rates, or both with larger routines
distinguished among sizes larger than 200 lines,
and you're bound to run into an upper limit of understandability as you pass 200 lines of code.
_____

=== Naming Functions

[quote, Steve McConnell, "Code Complete, Second Edition"]
_____
*Good Routine Names*

A good name for a routine clearly describes everything the routine does. Here are guidelines for creating effective routine names:

Describe everything the routine does. In the routine's name, describe all the outputs and side effects.
[...] If you have routines with side effects, you'll have many long, silly names.
The cure is not to use less-descriptive routine names;
the cure is to program so that you cause things to happen directly rather than with side effects.

Avoid meaningless, vague, or wishy-washy verbs.
[...] Sometimes the only problem with a routine is that its name is wishy-washy;
the routine itself might actually be well designed.
[...] In other cases, the verb is vague because the operations performed by the routine are vague.
The routine suffers from a weakness of purpose, and the weak name is a symptom.

[...] Don't differentiate routine names solely by number.

[...] Make names of routines as long as necessary.
Research shows that the optimum average length for a variable name is 9 to 15 characters.
Routines tend to be more complicated than variables, and good names for them tend to be longer.

[...] To name a function ["pure function" - Karl], use a description of the return value.
A function returns a value, and the function should be named for the value it returns.

[...] To name a procedure ["impure function" - Karl], use a strong verb followed by an object.
A procedure with functional cohesion usually performs an operation on an object.
The name should reflect what the procedure does, and an operation on an object implies a verb-plus-object name.

[...] In object-oriented languages,
you don't need to include the name of the object in the procedure name because the object itself is included in the call.

[...] Use opposites precisely.
Using naming conventions for opposites helps consistency, which helps readability.
Opposite-pairs like first/last are commonly understood.
[In the book, there is a table of such pairs. -Karl]

[...] Establish conventions for common operations.
In some systems, it's important to distinguish among different kinds of operations.
A naming convention is often the easiest and most reliable way of indicating these distinctions.
_____

== Clean Code (Ottinger)

=== Function Design

[quote, Tim Ottinger, Clean Code]
_____
*Small!*

The first rule of functions is that they should be small.
The second rule of functions is that *they should be smaller than that.*

[...] This implies that the blocks within if statements, else statements, while statements, and so on should be one line long.
Probably that line should be a function call.
Not only does this keep the enclosing function small,
but it also adds documentary value
because the function called within the block can have a nicely descriptive name.

This also implies that functions should not be large enough to hold nested structures.
Therefore, the indent level of a function should not be greater than one or two.
This, of course, makes the functions easier to read and understand.

*DO ONE THING*

The following advice has appeared in one form or another for 30 years or more.

FUNCTIONS SHOULD DO ONE THING.
THEY SHOULD DO IT WELL.
THEY SHOULD DO IT ONLY.

[...] If a function does only those steps that are one level below the stated name of the function,
then the function is doing one thing.

[...] Another way to know that a function is doing more than “one thing”
is if you can extract another function from it
with a name that is not merely a restatement of its implementation [G34].

*One Level of Abstraction per Function*

In order to make sure our functions are doing "one thing,"
we need to make sure that the statements within our function are all at the same level of abstraction.

*Reading Code from Top to Bottom: The Stepdown Rule*

We want the code to read like a top-down narrative.
[Kernighan and Plaugher, The Elements of Programming Style, 2d. ed., McGraw-Hill, 1978, p. 37.]
We want every function to be followed by those at the next level of abstraction so that we can read the program,
descending one level of abstraction at a time as we read down the list of functions.
I call this The Step-down Rule.

To say this differently, we want to be able to read the program as though it were a set of TO paragraphs,
each of which is describing the current level of abstraction and referencing subsequent TO paragraphs at the next level down.

*Switch Statements*
[NOTe: This is called "logical cohesion" in Code Complete -Karl]

It’s hard to make a small switch statement.
[And, of course, I include if/else chains in this.]
Even a switch statement with only two cases is larger than I’d like a single block or function to be.
It’s also hard to make a switch statement that does one thing.
By their nature, switch statements always do N things.
Unfortunately we can’t always avoid switch statements,
but we can make sure that each switch statement is buried in a low-level class and is never repeated.
We do this, of course, with polymorphism.

There are several problems with this function [with a switch-statement involving employee types].
First, it’s large, and when new employee types are added, it will grow.
Second, it very clearly does more than one thing.
Third, it violates the http://www.objectmentor.com/resources/articles/srp.pdf[Single Responsibility Principle] (SRP)
because there is more than one reason for it to change.
Fourth, it violates the http://www.objectmentor.com/resources/articles/ocp.pdf[Open Closed Principle] (OCP)
because it must change whenever new types are added.
But possibly the worst problem with this function is that there are an unlimited number of other functions that will have the same structure.

The solution to this problem is to bury the switch statement in the basement of an ABSTRACT FACTORY, and never let anyone see it.
[...] My general rule for switch statements is that they can be tolerated if they appear only once,
are used to create polymorphic objects,
and are hidden behind an inheritance relationship so that the rest of the system can’t see them [G23].

*Use Descriptive Names*

[...] It is hard to overestimate the value of good names.
Remember Ward’s principle: "You know you are working on clean code when each routine turns out to be pretty much what you expected."
Half the battle to achieving that principle is choosing good names for small functions that do one thing.
The smaller and more focused a function is, the easier it is to choose a descriptive name.

[...] Don’t be afraid to make a name long.
A long descriptive name is better than a short enigmatic name.
A long descriptive name is better than a long descriptive comment.

[...] Don’t be afraid to spend time choosing a name.

[...] Be consistent in your names.
Use the same phrases, nouns, and verbs in the function names you choose for your modules.

*Function Arguments*

The ideal number of arguments for a function is zero (niladic).
[NOTE: I completely disagree, as it makes the function impure. -Karl]
Next comes one (monadic), followed closely by two (dyadic).
Three arguments (triadic) should be avoided where possible.
More than three (polyadic) requires very special justification—and then shouldn’t be used anyway.

[...] Arguments are even harder from a testing point of view.
Imagine the difficulty of writing all the test cases to ensure that all the various combinations of arguments work properly.

[...] Output arguments are harder to understand than input arguments.
When we read a function, we are used to the idea of information going in to the function through arguments and out through the return value.
We don’t usually expect information to be going out through the arguments.
So output arguments often cause us to do a double-take.
[NOTE: This can be better expressed as "prefer pure functions." - Karl]

[...] Flag arguments are ugly. Passing a boolean into a function is a truly terrible practice.
It immediately complicates the signature of the method, loudly proclaiming that this function does more than one thing.

[...] When a function seems to need more than two or three arguments, it is likely that some of those arguments ought to be wrapped into a class of their own.
[NOTE: Or a `struct` in C. -Karl]

[...] Sometimes we want to pass a variable number of arguments into a function.
[...] If the variable arguments are all treated identically, [...] then they are equivalent to a single argument[.]

[...] Choosing good names for a function can go a long way toward explaining the intent of the function and the order and intent of the arguments.
In the case of a monad, the function and argument should form a very nice verb/noun pair.
For example, write(name) is very evocative.
Whatever this “name” thing is, it is being “written.”
An even better name might be writeField(name), which tells us that the “name” thing is a “field.”

This last is an example of the *keyword* form of a function name.
Using this form we encode the names of the arguments into the function name.

*Have No Side Effects*

Side effects are lies.
Your function promises to do one thing, but it also does other hidden things.
[NOTE: Again, "prefer pure functions." - Karl]

[...] This side effect creates a temporal coupling.
That is, checkPassword can only be called at certain times (in other words, when it is safe to initialize the session).
If it is called out of order, session data may be inadvertently lost.
Temporal couplings are confusing, especially when hidden as a side effect.
[NOTE: Included because of the term "temporal coupling." -Karl]

*COMMAND QUERY SEPARATION*

Functions should either do something or answer something, but not both.
Either your function should change the state of an object, or it should return some information about that object.
Doing both often leads to confusion.

*PREFER EXCEPTIONS TO RETURNING ERROR CODES*

Returning error codes from command functions is a subtle violation of command query separation.
It promotes commands being used as expressions in the predicates of `if` statements.

[...] `Try`/`catch` blocks are ugly in their own right.
They confuse the structure of the code and mix error processing with normal processing.
So it is better to extract the bodies of the `try` and `catch` blocks out into functions of their own.

[...] Functions should do one thing.
Error handing is one thing.
Thus, a function that handles errors should do nothing else.
This implies [...] that if the keyword `try` exists in a function,
it should be the very first word in the function and that there should be nothing after the `catch`/`finally` blocks.

[...] Returning error codes usually implies that there is some class or enum in which all the error codes are defined.
[...] Classes like this are a *dependency magnet;* many other classes must import and use them.
Thus, when the Error enum changes, all those other classes need to be recompiled and redeployed.
[...] When you use exceptions rather than error codes, then new exceptions are derivatives of the exception class.
They can be added without forcing any recompilation or redeployment.
[This is an example of the Open Closed Principle (OCP) [Robert C. Martin, Agile Software Development: Principles, Patterns, and Practices, Prentice Hall, 2002].]

*DON’T REPEAT YOURSELF*

[The DRY principle. [The Pragmatic Programmer, Andrew Hunt, Dave Thomas, Addison-Wesley, 2000].]

Duplication may be the root of all evil in software.
Many principles and practices have been created for the purpose of controlling or eliminating it.

*STRUCTURED PROGRAMMING*
Some programmers follow Edsger Dijkstra’s rules of structured programming.
[Structured Programming, O.-J. Dahl, E. W. Dijkstra, C. A. R. Hoare, Academic Press, London, 1972]
Dijkstra said that every function, and every block within a function, should have one entry and one exit.
Following these rules means that there should only be one `return` statement in a function,
no `break` or `continue` statements in a loop,
and never, ever, any `goto` statements.

While we are sympathetic to the goals and disciplines of structured programming, those rules serve little benefit when functions are very small.
It is only in larger functions that such rules provide significant benefit.

So if you keep your functions small, then the occasional multiple `return`, `break`, or `continue` statement does no harm
and can sometimes even be more expressive than the single-entry, single-exit rule.
On the other hand, `goto` only makes sense in large functions, so it should be avoided.
_____

=== Naming Functions

[quote, Tim Ottinger, Clean Code]
_____
*USE INTENTION-REVEALING NAMES*

[...] The name of a variable, function, or class, should answer all the big questions.
It should tell you why it exists, what it does, and how it is used.
If a name requires a comment, then the name does not reveal its intent.

*AVOID DISINFORMATION*

Programmers must avoid leaving false clues that obscure the meaning of code.
We should avoid words whose entrenched meanings vary from our intended meaning.
For example, `hp`, `aix`, and `sco` would be poor variable names because they are the names of Unix platforms or variants.
Even if you are coding a hypotenuse and hp looks like a good abbreviation, it could be disinformative.

*MAKE MEANINGFUL DISTINCTIONS*

Programmers create problems for themselves when they write code solely to satisfy a compiler or interpreter.
For example, because you can’t use the same name to refer to two different things in the same scope, you might be tempted to change one name in an arbitrary way.
Sometimes this is done by misspelling one, leading to the surprising situation where correcting spelling errors leads to an inability to compile.

It is not sufficient to add number series or noise words, even though the compiler is satisfied.
If names must be different, then they should also mean something different.

[...] In the absence of specific conventions, the variable moneyAmount is indistinguishable from money, customerInfo is indistinguishable from customer, accountData is indistinguishable from account, and theMessage is indistinguishable from message.
Distinguish names in such a way that the reader knows what the differences offer.

*USE PRONOUNCEABLE NAMES*

Humans are good at words.
A significant part of our brains is dedicated to the concept of words.
And words are, by definition, pronounceable.
It would be a shame not to take advantage of that huge portion of our brains that has evolved to deal with spoken language.
So make your names pronounceable.

If you can’t pronounce it, you can’t discuss it without sounding like an idiot.
"Well, over here on the bee cee arr three cee enn tee we have a pee ess zee kyew int, see?"
This matters because programming is a social activity.

*USE SEARCHABLE NAMES*

Single-letter names and numeric constants have a particular problem in that they are not easy to locate across a body of text.

[...] My personal preference is that single-letter names can ONLY be used as local variables inside short methods.
*The length of a name should correspond to the size of its scope [N5].*
If a variable or constant might be seen or used in multiple places in a body of code, it is imperative to give it a search-friendly name.

*AVOID ENCODINGS*

We have enough encodings to deal with without adding more to our burden.
Encoding type or scope information into names simply adds an extra burden of deciphering.
It hardly seems reasonable to require each new employee to learn yet another encoding “language” in addition to learning the (usually considerable) body of code that they’ll be working in.
It is an unnecessary mental burden when trying to solve a problem.
Encoded names are seldom pronounceable and are easy to mis-type.

*Hungarian Notation*

In days of old, when we worked in name-length-challenged languages, we violated this rule out of necessity, and with regret.

[...] Nowadays HN and other forms of type encoding are simply impediments.
They make it harder to change the name or type of a variable, function, or class.
They make it harder to read the code.
And they create the possibility that the encoding system will mislead the reader.

*Member Prefixes*

You also don’t need to prefix member variables with `m_` anymore.
Your classes and functions should be small enough that you don’t need them.
And you should be using an editing environment that highlights or colorizes members to make them distinct.

[...] Besides, people quickly learn to ignore the prefix (or suffix) to see the meaningful part of the name.
The more we read the code, the less we see the prefixes.
Eventually the prefixes become unseen clutter and a marker of older code.

*Interfaces and Implementations*

These are sometimes a special case for encodings.
For example, say you are building an ABSTRACT FACTORY for the creation of shapes.
This factory will be an interface and will be implemented by a concrete class.
What should you name them?
`IShapeFactory` and `ShapeFactory`?
I prefer to leave interfaces unadorned.
The preceding `I`, so common in today’s legacy wads, is a distraction at best and too much information at worst.
I don’t want my users knowing that I’m handing them an interface.
I just want them to know that it’s a `ShapeFactory`.
So if I must encode either the interface or the implementation, I choose the implementation.
Calling it `ShapeFactoryImp`, or even the hideous `CShapeFactory`, is preferable to encoding the interface.

*AVOID MENTAL MAPPING*

Readers shouldn’t have to mentally translate your names into other names they already know.
This problem generally arises from a choice to use neither problem domain terms nor solution domain terms.

This is a problem with single-letter variable names.
Certainly a loop counter may be named `i` or `j` or `k` (though never `l`!) if its scope is very small and no other names can conflict with it.
This is because those single-letter names for loop counters are traditional.
However, in most other contexts a single-letter name is a poor choice; it’s just a place holder that the reader must mentally map to the actual concept.
There can be no worse reason for using the name `c` than because `a` and `b` were already taken.

*METHOD NAMES*

Methods should have verb or verb phrase names like postPayment, deletePage, or save.
Accessors, mutators, and predicates should be named for their value and prefixed with `get`, `set`, and `is` according to the javabean standard.

*Don’t Be Cute*

If names are too clever, they will be memorable only to people who share the author’s sense of humor,
and only as long as these people remember the joke.

*Pick One Word per Concept*

Pick one word for one abstract concept and stick with it.
For instance, it’s confusing to have fetch, retrieve, and get as equivalent methods of different classes.
How do you remember which method name goes with which class?

*DON’T PUN*

Avoid using the same word for two purposes.
Using the same term for two different ideas is essentially a pun.

[...] Our goal, as authors, is to make our code as easy as possible to understand.
 We want our code to be a quick skim, not an intense study.
We want to use the popular paperback model whereby the author is responsible for making himself clear and not the academic model where it is the scholar’s job to dig the meaning out of the paper.

*Use Solution Domain Names*

Remember that the people who read your code will be programmers.
So go ahead and use computer science (CS) terms, algorithm names, pattern names, math terms, and so forth.

*Use Problem Domain Names*

When there is no “programmer-eese” for what you’re doing, use the name from the problem domain.
At least the programmer who maintains your code can ask a domain expert what it means.

*Add Meaningful Context*

There are a few names which are meaningful in and of themselves—most are not.
Instead, you need to place names in context for your reader by enclosing them in well-named classes, functions, or namespaces.
When all else fails, then prefixing the name may be necessary as a last resort.

*Don’t Add Gratuitous Context*

In an imaginary application called “Gas Station Deluxe,” it is a bad idea to prefix every class with GSD.
Frankly, you are working against your tools.
You type G and press the completion key and are rewarded with a mile-long list of every class in the system.
Is that wise?
Why make it hard for the IDE to help you?

Likewise, say you invented a MailingAddress class in GSD’s accounting module, and you named it GSDAccountAddress.
Later, you need a mailing address for your customer contact application.
Do you use GSDAccountAddress?
Does it sound like the right name?
Ten of 17 characters are redundant or irrelevant.

Shorter names are generally better than longer ones, so long as they are clear.
Add no more context to a name than is necessary.
_____
